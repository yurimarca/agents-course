# Creando una Herramienta RAG para Historias de Invitados


Alfred, tu agente de confianza, est√° preparando la gala m√°s extravagante del siglo. Para asegurar que el evento transcurra sin problemas, Alfred necesita acceso r√°pido a informaci√≥n actualizada sobre cada invitado. Ayudemos a Alfred creando una herramienta personalizada de Generaci√≥n Aumentada por Recuperaci√≥n (RAG), impulsada por nuestro conjunto de datos personalizado.

## ¬øPor qu√© RAG para una Gala?

Imagina a Alfred mezcl√°ndose entre los invitados, necesitando recordar detalles espec√≠ficos sobre cada persona en un instante. Un LLM tradicional podr√≠a tener dificultades con esta tarea porque:

1. La lista de invitados es espec√≠fica para tu evento y no est√° en los datos de entrenamiento del modelo
2. La informaci√≥n de los invitados puede cambiar o actualizarse frecuentemente
3. Alfred necesita recuperar detalles precisos como direcciones de correo electr√≥nico

Aqu√≠ es donde brilla la Generaci√≥n Aumentada por Recuperaci√≥n (RAG)! Al combinar un sistema de recuperaci√≥n con un LLM, Alfred puede acceder a informaci√≥n precisa y actualizada sobre tus invitados bajo demanda.

<Tip>

Puedes elegir cualquiera de los frameworks cubiertos en el curso para este caso de uso. Selecciona tu opci√≥n preferida de las pesta√±as de c√≥digo.

</Tip>

## Configurando nuestra aplicaci√≥n

En esta unidad, desarrollaremos nuestro agente dentro de un Espacio de HF(HF Space), como un proyecto Python estructurado. Este enfoque nos ayuda a mantener un c√≥digo limpio y modular, organizando diferentes funcionalidades en archivos separados. Adem√°s, esto crea un caso de uso m√°s realista donde desplegar√≠as la aplicaci√≥n para uso p√∫blico.

### Estructura del Proyecto

- **`tools.py`** ‚Äì Proporciona herramientas auxiliares para el agente.  
- **`retriever.py`** ‚Äì Implementa funciones de recuperaci√≥n para apoyar el acceso al conocimiento.  
- **`app.py`** ‚Äì Integra todos los componentes en un agente completamente funcional, que finalizaremos en la √∫ltima parte de esta unidad.  

Para una referencia pr√°ctica, consulta [este Espacio de HF](https://huggingface.co/spaces/agents-course/Unit_3_Agentic_RAG), donde el RAG Ag√©ntico desarrollado en esta unidad est√° en vivo. ¬°Si√©ntete libre de clonarlo y experimentar!

Puedes probar directamente el agente a continuaci√≥n:

<iframe
	src="https://agents-course-unit-3-agentic-rag.hf.space"
	frameborder="0"
	width="850"
	height="450"
></iframe>

## Descripci√≥n General del Conjunto de Datos

Nuestro conjunto de datos [`agents-course/unit3-invitees`](https://huggingface.co/datasets/agents-course/unit3-invitees/) contiene los siguientes campos para cada invitado:

- **Nombre**: Nombre completo del invitado
- **Relaci√≥n**: C√≥mo se relaciona el invitado con el anfitri√≥n
- **Descripci√≥n**: Una breve biograf√≠a o hechos interesantes sobre el invitado
- **Direcci√≥n de Correo Electr√≥nico**: Informaci√≥n de contacto para enviar invitaciones o seguimientos

A continuaci√≥n se muestra una vista previa del conjunto de datos:
<iframe
  src="https://huggingface.co/datasets/agents-course/unit3-invitees/embed/viewer/default/train"
  frameborder="0"
  width="100%"
  height="560px"
></iframe>

<Tip>
En un escenario del mundo real, este conjunto de datos podr√≠a ampliarse para incluir preferencias diet√©ticas, intereses de regalos, temas de conversaci√≥n a evitar y otros detalles √∫tiles para un anfitri√≥n.
</Tip>

## Construyendo la Herramienta de Lista de Invitados

Crearemos una herramienta personalizada que Alfred pueda usar para recuperar r√°pidamente informaci√≥n de los invitados durante la gala. Dividamos esto en tres pasos manejables:

1. Cargar y preparar el conjunto de datos
2. Crear la Herramienta de Recuperaci√≥n
3. Integrar la Herramienta con Alfred

¬°Comencemos con la carga y preparaci√≥n del conjunto de datos!

### Paso 1: Cargar y Preparar el Conjunto de Datos

Primero, necesitamos transformar nuestros datos brutos de invitados en un formato optimizado para la recuperaci√≥n.

<hfoptions id="agents-frameworks">
<hfoption id="smolagents">

Usaremos la librer√≠a `datasets` de Hugging Face para cargar el conjunto de datos y convertirlo en una lista de objetos `Document` del m√≥dulo `langchain.docstore.document`.

```python
import datasets
from langchain.docstore.document import Document

# Cargar el conjunto de datos
guest_dataset = datasets.load_dataset("agents-course/unit3-invitees", split="train")

# Convertir entradas del conjunto de datos en objetos Document
docs = [
    Document(
        page_content="\n".join([
            f"Name: {guest['name']}",
            f"Relation: {guest['relation']}",
            f"Description: {guest['description']}",
            f"Email: {guest['email']}"
        ]),
        metadata={"name": guest["name"]}
    )
    for guest in guest_dataset
]

```

</hfoption>
<hfoption id="llama-index">

Usaremos la librer√≠a `datasets` de Hugging Face para cargar el conjunto de datos y convertirlo en una lista de objetos `Document` del m√≥dulo `llama_index.core.schema`.

```python
import datasets
from llama_index.core.schema import Document

# Cargar el conjunto de datos
guest_dataset = datasets.load_dataset("agents-course/unit3-invitees", split="train")

# Convertir entradas del conjunto de datos en objetos Document
docs = [
    Document(
        text="\n".join([
            f"Name: {guest_dataset['name'][i]}",
            f"Relation: {guest_dataset['relation'][i]}",
            f"Description: {guest_dataset['description'][i]}",
            f"Email: {guest_dataset['email'][i]}"
        ]),
        metadata={"name": guest_dataset['name'][i]}
    )
    for i in range(len(guest_dataset))
]
```

</hfoption>
<hfoption id="langgraph">

Usaremos la librer√≠a `datasets` de Hugging Face para cargar el conjunto de datos y convertirlo en una lista de objetos `Document` del m√≥dulo `langchain.docstore.document`.

```python
import datasets
from langchain.docstore.document import Document

# Cargar el conjunto de datos
guest_dataset = datasets.load_dataset("agents-course/unit3-invitees", split="train")

# Convertir entradas del conjunto de datos en objetos Document
docs = [
    Document(
        page_content="\n".join([
            f"Name: {guest['name']}",
            f"Relation: {guest['relation']}",
            f"Description: {guest['description']}",
            f"Email: {guest['email']}"
        ]),
        metadata={"name": guest["name"]}
    )
    for guest in guest_dataset
]
```

</hfoption>
</hfoptions>

En el c√≥digo anterior:
- Cargamos el conjunto de datos
- Convertimos cada entrada de invitado en un objeto `Document` con contenido formateado
- Almacenamos los objetos `Document` en una lista

Esto significa que tenemos todos nuestros datos disponibles de manera ordenada para poder comenzar a configurar nuestra recuperaci√≥n.

### Paso 2: Crear la Herramienta de Recuperaci√≥n

Ahora, creemos una herramienta personalizada que Alfred pueda usar para buscar en nuestra informaci√≥n de invitados.

<hfoptions id="agents-frameworks">
<hfoption id="smolagents">

Usaremos el `BM25Retriever` del m√≥dulo `langchain_community.retrievers` para crear una herramienta de recuperaci√≥n.

<Tip>
  El <code>BM25Retriever</code> es un gran punto de partida para la recuperaci√≥n, pero para b√∫squedas sem√°nticas m√°s avanzadas, podr√≠as considerar usar recuperadores basados en embeddings como los de <a href="https://www.sbert.net/">sentence-transformers</a>.
</Tip>

```python
from smolagents import Tool
from langchain_community.retrievers import BM25Retriever

class GuestInfoRetrieverTool(Tool):
    name = "guest_info_retriever"
    description = "Recupera informaci√≥n detallada sobre los invitados de la gala basada en su nombre o relaci√≥n."
    inputs = {
        "query": {
            "type": "string",
            "description": "El nombre o relaci√≥n del invitado sobre el que deseas informaci√≥n."
        }
    }
    output_type = "string"

    def __init__(self, docs):
        self.is_initialized = False
        self.retriever = BM25Retriever.from_documents(docs)

    def forward(self, query: str):
        results = self.retriever.get_relevant_documents(query)
        if results:
            return "\n\n".join([doc.page_content for doc in results[:3]])
        else:
            return "No se encontr√≥ informaci√≥n que coincida con la b√∫squeda."

# Inicializar la herramienta
guest_info_tool = GuestInfoRetrieverTool(docs)
```

Entendamos esta herramienta paso a paso: 
- El `name` y la `description` ayudan al agente a entender cu√°ndo y c√≥mo usar esta herramienta
- Los `inputs` definen qu√© par√°metros espera la herramienta (en este caso, una consulta de b√∫squeda)
- Estamos usando un `BM25Retriever`, que es un algoritmo poderoso de recuperaci√≥n de texto que no requiere embeddings
- El m√©todo `forward` procesa la consulta y devuelve la informaci√≥n m√°s relevante del invitado

</hfoption>
<hfoption id="llama-index">

Usaremos el `BM25Retriever` del m√≥dulo `llama_index.retrievers.bm25` para crear una herramienta de recuperaci√≥n.

<Tip>
  El <code>BM25Retriever</code> es un gran punto de partida para la recuperaci√≥n, pero para b√∫squedas sem√°nticas m√°s avanzadas, podr√≠as considerar usar recuperadores basados en embeddings como los de <a href="https://www.sbert.net/">sentence-transformers</a>.
</Tip>

```python
from llama_index.core.tools import FunctionTool
from llama_index.retrievers.bm25 import BM25Retriever

bm25_retriever = BM25Retriever.from_defaults(nodes=docs)

def get_guest_info_retriever(query: str) -> str:
    """Recupera informaci√≥n detallada sobre los invitados de la gala basada en su nombre o relaci√≥n."""
    results = bm25_retriever.retrieve(query)
    if results:
        return "\n\n".join([doc.text for doc in results[:3]])
    else:
        return "No se encontr√≥ informaci√≥n que coincida con la b√∫squeda."

# Inicializar la herramienta
guest_info_tool = FunctionTool.from_defaults(get_guest_info_retriever)
```

Entendamos esta herramienta paso a paso: 
- El docstring ayuda al agente a entender cu√°ndo y c√≥mo usar esta herramienta
- Los decoradores de tipo definen qu√© par√°metros espera la herramienta (en este caso, una consulta de b√∫squeda)
- Estamos usando un `BM25Retriever`, que es un algoritmo poderoso de recuperaci√≥n de texto que no requiere embeddings
- El m√©todo procesa la consulta y devuelve la informaci√≥n m√°s relevante del invitado

</hfoption>
<hfoption id="langgraph">

Usaremos el `BM25Retriever` del m√≥dulo `langchain_community.retrievers` para crear una herramienta de recuperaci√≥n.

<Tip>
  El <code>BM25Retriever</code> es un gran punto de partida para la recuperaci√≥n, pero para b√∫squedas sem√°nticas m√°s avanzadas, podr√≠as considerar usar recuperadores basados en embeddings como los de <a href="https://www.sbert.net/">sentence-transformers</a>.
</Tip>

```python
from langchain_community.retrievers import BM25Retriever
from langchain.tools import Tool

bm25_retriever = BM25Retriever.from_documents(docs)

def extract_text(query: str) -> str:
    """Recupera informaci√≥n detallada sobre los invitados de la gala basada en su nombre o relaci√≥n."""
    results = bm25_retriever.invoke(query)
    if results:
        return "\n\n".join([doc.text for doc in results[:3]])
    else:
        return "No se encontr√≥ informaci√≥n que coincida con la b√∫squeda."

guest_info_tool = Tool(
    name="guest_info_retriever",
    func=extract_text,
    description="Recupera informaci√≥n detallada sobre los invitados de la gala basada en su nombre o relaci√≥n."
)
```

Entendamos esta herramienta paso a paso: 
- El `name` y la `description` ayudan al agente a entender cu√°ndo y c√≥mo usar esta herramienta
- Los decoradores de tipo definen qu√© par√°metros espera la herramienta (en este caso, una consulta de b√∫squeda)
- Estamos usando un `BM25Retriever`, que es un potente algoritmo de recuperaci√≥n de texto que no requiere embeddings
- El m√©todo procesa la consulta y devuelve la informaci√≥n m√°s relevante del invitado


</hfoption>
</hfoptions>

### Paso 3: Integrar la Herramienta con Alfred

Finalmente, juntemos todo creando nuestro agente y equip√°ndolo con nuestra herramienta personalizada:

<hfoptions id="agents-frameworks">
<hfoption id="smolagents">

```python
from smolagents import CodeAgent, HfApiModel

# Inicializar el modelo de Hugging Face
model = HfApiModel()

# Crear Alfred, nuestro agente de gala, con la herramienta de informaci√≥n de invitados
alfred = CodeAgent(tools=[guest_info_tool], model=model)

# Ejemplo de consulta que Alfred podr√≠a recibir durante la gala
response = alfred.run("Cu√©ntame sobre nuestra invitada llamada 'Lady Ada Lovelace'.")

print("üé© Respuesta de Alfred:")
print(response)
```

Salida esperada:

```
üé© Respuesta de Alfred:
Basado en la informaci√≥n que recuper√©, Lady Ada Lovelace es una estimada matem√°tica y amiga. Es reconocida por su trabajo pionero en matem√°ticas e inform√°tica, a menudo celebrada como la primera programadora de computadoras debido a su trabajo en la M√°quina Anal√≠tica de Charles Babbage. Su direcci√≥n de correo electr√≥nico es ada.lovelace@example.com.
```

Lo que est√° sucediendo en este paso final:
- Inicializamos un modelo de Hugging Face usando la clase `HfApiModel`
- Creamos nuestro agente (Alfred) como un `CodeAgent`, que puede ejecutar c√≥digo Python para resolver problemas
- Le pedimos a Alfred que recupere informaci√≥n sobre una invitada llamada "Lady Ada Lovelace"

</hfoption>
<hfoption id="llama-index">

```python
from llama_index.core.agent.workflow import AgentWorkflow
from llama_index.llms.huggingface_api import HuggingFaceInferenceAPI

# Inicializar el modelo de Hugging Face
llm = HuggingFaceInferenceAPI(model_name="Qwen/Qwen2.5-Coder-32B-Instruct")

# Crear a Alfred, nuestro agente de gala, con la herramienta de informaci√≥n de invitados
alfred = AgentWorkflow.from_tools_or_functions(
    [guest_info_tool],
    llm=llm,
)

# Ejemplo de consulta que Alfred podr√≠a recibir durante la gala
response = await alfred.run("Cu√©ntame sobre nuestra invitada llamada 'Lady Ada Lovelace'.")

print("üé© Respuesta de Alfred:")
print(response)
```

Salida esperada:

```
üé© Respuesta de Alfred:
Lady Ada Lovelace es una estimada matem√°tica y amiga, reconocida por su trabajo pionero en matem√°ticas e inform√°tica. Es celebrada como la primera programadora de computadoras debido a su trabajo en la M√°quina Anal√≠tica de Charles Babbage. Su correo electr√≥nico es ada.lovelace@example.com.
```

Lo que est√° sucediendo en este paso final:
- Inicializamos un modelo de Hugging Face usando la clase `HuggingFaceInferenceAPI`
- Creamos nuestro agente (Alfred) como un `AgentWorkflow`, incluyendo la herramienta que acabamos de crear
- Le pedimos a Alfred que recupere informaci√≥n sobre una invitada llamada "Lady Ada Lovelace"

</hfoption>
<hfoption id="langgraph">

```python
from typing import TypedDict, Annotated
from langgraph.graph.message import add_messages
from langchain_core.messages import AnyMessage, HumanMessage, AIMessage
from langgraph.prebuilt import ToolNode
from langgraph.graph import START, StateGraph
from langgraph.prebuilt import tools_condition
from langchain_huggingface import HuggingFaceEndpoint, ChatHuggingFace

# Generar la interfaz de chat, incluyendo las herramientas
llm = HuggingFaceEndpoint(
    repo_id="Qwen/Qwen2.5-Coder-32B-Instruct",
    huggingfacehub_api_token=HUGGINGFACEHUB_API_TOKEN,
)

chat = ChatHuggingFace(llm=llm, verbose=True)
tools = [guest_info_tool]
chat_with_tools = chat.bind_tools(tools)

# Generar el AgentState y el grafo del Agente
class AgentState(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]

def assistant(state: AgentState):
    return {
        "messages": [chat_with_tools.invoke(state["messages"])],
    }

## El grafo
builder = StateGraph(AgentState)

# Definir nodos: estos hacen el trabajo
builder.add_node("assistant", assistant)
builder.add_node("tools", ToolNode(tools))

# Definir bordes: estos determinan c√≥mo se mueve el flujo de control
builder.add_edge(START, "assistant")
builder.add_conditional_edges(
    "assistant",
    # Si el √∫ltimo mensaje requiere una herramienta, enrutar a herramientas
    # De lo contrario, proporcionar una respuesta directa
    tools_condition,
)
builder.add_edge("tools", "assistant")
alfred = builder.compile()

messages = [HumanMessage(content="Cu√©ntame sobre nuestra invitada llamada 'Lady Ada Lovelace'.")]
response = alfred.invoke({"messages": messages})

print("üé© Respuesta de Alfred:")
print(messages['messages'][-1].content)
```

Salida esperada:

```
üé© Respuesta de Alfred:
Lady Ada Lovelace es una estimada matem√°tica y pionera en inform√°tica, a menudo celebrada como la primera programadora de computadoras debido a su trabajo en la M√°quina Anal√≠tica de Charles Babbage.
```

Lo que est√° sucediendo en este paso final:
- Inicializamos un modelo de Hugging Face usando la clase `HuggingFaceEndpoint`. Tambi√©n generamos una interfaz de chat y a√±adimos las herramientas.
- Creamos nuestro agente (Alfred) como un `StateGraph`, que combina 2 nodos (`assistant`, `tools`) usando un borde
- Le pedimos a Alfred que recupere informaci√≥n sobre una invitada llamada "Lady Ada Lovelace"

</hfoption>
</hfoptions>

## Ejemplo de Interacci√≥n

Durante la gala, una conversaci√≥n podr√≠a fluir as√≠:

**T√∫:** "Alfred, ¬øqui√©n es ese caballero hablando con el embajador?"

**Alfred:** *r√°pidamente busca en la base de datos de invitados* "Ese es el Dr. Nikola Tesla, se√±or. Es un viejo amigo de sus d√≠as universitarios. Recientemente ha patentado un nuevo sistema de transmisi√≥n de energ√≠a inal√°mbrica y estar√≠a encantado de discutirlo con usted. Solo recuerde que es apasionado por las palomas, as√≠ que eso podr√≠a ser un buen tema de conversaci√≥n."

```json
{
    "name": "Dr. Nikola Tesla",
    "relation": "viejo amigo de d√≠as universitarios",  
    "description": "El Dr. Nikola Tesla es un viejo amigo de sus d√≠as universitarios. Recientemente ha patentado un nuevo sistema de transmisi√≥n de energ√≠a inal√°mbrica y estar√≠a encantado de discutirlo con usted. Solo recuerde que es apasionado por las palomas, as√≠ que eso podr√≠a ser un buen tema de conversaci√≥n.",
    "email": "nikola.tesla@gmail.com"
}
```

## Llev√°ndolo M√°s All√°

Ahora que Alfred puede recuperar informaci√≥n de invitados, considera c√≥mo podr√≠as mejorar este sistema:

1. **Mejorar el recuperador** para usar un algoritmo m√°s sofisticado como [sentence-transformers](https://www.sbert.net/)
2. **Implementar una memoria de conversaci√≥n** para que Alfred recuerde interacciones previas
3. **Combinar con b√∫squeda web** para obtener la informaci√≥n m√°s reciente sobre invitados desconocidos
4. **Integrar m√∫ltiples √≠ndices** para obtener informaci√≥n m√°s completa de fuentes verificadas

¬°Ahora Alfred est√° completamente equipado para manejar consultas de invitados sin esfuerzo, asegurando que tu gala sea recordada como el evento m√°s sofisticado y encantador del siglo!

<Tip>
Intenta extender la herramienta de recuperaci√≥n para que tambi√©n devuelva iniciadores de conversaci√≥n basados en los intereses o antecedentes de cada invitado. ¬øC√≥mo modificar√≠as la herramienta para lograr esto?

Cuando hayas terminado, implementa tu herramienta de recuperaci√≥n de invitados en el archivo <code>retriever.py</code>.
</Tip>
