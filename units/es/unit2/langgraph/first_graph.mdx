# Construyendo Tu Primer LangGraph

Ahora que entendemos los componentes b치sicos, vamos a ponerlos en pr치ctica construyendo nuestro primer grafo funcional. Implementaremos el sistema de procesamiento de correos electr칩nicos de Alfred, donde necesita:

1. Leer correos electr칩nicos entrantes
2. Clasificarlos como spam o leg칤timos
3. Redactar una respuesta preliminar para correos leg칤timos
4. Enviar informaci칩n al Sr. Wayne cuando son leg칤timos (solo impresi칩n)

Este ejemplo demuestra c칩mo estructurar un flujo de trabajo con LangGraph que involucra toma de decisiones basada en LLM. Aunque esto no puede considerarse un Agente ya que no se involucra ninguna herramienta, esta secci칩n se enfoca m치s en aprender el marco de trabajo de LangGraph que en Agentes.

<Tip>
Puedes seguir el c칩digo en <a href="https://huggingface.co/agents-course/notebooks/resolve/main/unit2/langgraph/mail_sorting.ipynb" target="_blank">este notebook</a> que puedes ejecutar usando Google Colab.
</Tip>
## Nuestro Flujo de Trabajo

Aqu칤 est치 el flujo de trabajo que construiremos:
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/first_graph.png" alt="First LangGraph"/>

## Configurando Nuestro Entorno

Primero, instalemos los paquetes necesarios:

```python
%pip install langgraph langchain_openai
```

A continuaci칩n, importemos los m칩dulos necesarios:

```python
import os
from typing import TypedDict, List, Dict, Any, Optional
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage
```

## Paso 1: Definir Nuestro Estado

Definamos qu칠 informaci칩n necesita rastrear Alfred durante el flujo de trabajo de procesamiento de correos electr칩nicos:

```python
class EmailState(TypedDict):
    # El correo electr칩nico que se est치 procesando
    email: Dict[str, Any]  # Contiene asunto, remitente, cuerpo, etc.
    
    # An치lisis y decisiones
    is_spam: Optional[bool]
    
    # Generaci칩n de respuesta
    draft_response: Optional[str]
    
    # Metadatos de procesamiento
    messages: List[Dict[str, Any]]  # Rastrea la conversaci칩n con LLM para an치lisis
```

> 游눠 **Tip:** Haz que tu estado sea lo suficientemente completo para rastrear toda la informaci칩n importante, pero evita sobrecargarlo con detalles innecesarios.

## Paso 2: Definir Nuestros Nodos

Ahora, creemos las funciones de procesamiento que formar치n nuestros nodos:

```python
# Inicializar nuestro LLM
model = ChatOpenAI(temperature=0)

def read_email(state: EmailState):
    """Alfred lee y registra el correo electr칩nico entrante"""
    email = state["email"]
    
    # Aqu칤 podr칤amos hacer alg칰n preprocesamiento inicial
    print(f"Alfred est치 procesando un correo electr칩nico de {email['sender']} con asunto: {email['subject']}")
    
    # No se necesitan cambios de estado aqu칤
    return {}

def classify_email(state: EmailState):
    """Alfred usa un LLM para determinar si el correo es spam o leg칤timo"""
    email = state["email"]
    
     # Preparar nuestro prompt para el LLM
    prompt = f"""
    Como Alfred el mayordomo, analiza este correo electr칩nico y determina si es spam o leg칤timo.
    
    Email:
    De:  {email['sender']}
    Asunto: {email['subject']}
    Body: {email['body']}
    
    Primero, determina si este correo es spam. Si es spam, explica por qu칠.
    Si es leg칤timo, categor칤zalo (consulta, queja, agradecimiento, etc.).
    """
    
    # Llamar al LLM
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # L칩gica simple para analizar la respuesta (en una aplicaci칩n real, querr칤as un an치lisis m치s robusto)
    response_text = response.content.lower()
    is_spam = "spam" in response_text and "not spam" not in response_text
    
    # Extraer una raz칩n si es spam
    spam_reason = None
    if is_spam and "reason:" in response_text:
        spam_reason = response_text.split("reason:")[1].strip()
    
    # Determinar categor칤a si es leg칤timo
    email_category = None
    if not is_spam:
        categories = ["consulta", "queja", "agradecimiento", "solicitud", "informaci칩n"]
        for category in categories:
            if category in response_text:
                email_category = category
                break
    
    # Actualizar mensajes para seguimiento
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
     # Regresar actualizaciones de estado
    return {
        "is_spam": is_spam,
        "spam_reason": spam_reason,
        "email_category": email_category,
        "messages": new_messages
    }

def handle_spam(state: EmailState):
    """Alfred descarta el correo spam con una nota"""
    print(f"Alfred ha marcado el correo como spam. Raz칩n: {state['spam_reason']}")
    print("El correo ha sido movido a la carpeta de spam.")
    
    # Hemos terminado de procesar este correo
    return {}

def draft_response(state: EmailState):
    """Alfred redacta una respuesta preliminar para correos leg칤timos"""
    email = state["email"]
    category = state["email_category"] or "general"
    
   # Preparar nuestro prompt para el LLM
    prompt = f"""
    Como Alfred el mayordomo, redacta una respuesta preliminar cort칠s a este correo.
    
    Email:
    From: {email['sender']}
    Subject: {email['subject']}
    Body: {email['body']}
    
     ste correo ha sido categorizado como: {category}
    
    Redacta una respuesta breve y profesional que el Sr. Hugg pueda revisar y personalizar antes de enviar.
    """
    
    # Llamar al LLM
    messages = [HumanMessage(content=prompt)]
    response = model.invoke(messages)
    
    # Actualizar mensajes para seguimiento
    new_messages = state.get("messages", []) + [
        {"role": "user", "content": prompt},
        {"role": "assistant", "content": response.content}
    ]
    
     # Regresar actualizaciones de estado
    return {
        "draft_response": response.content,
        "messages": new_messages
    }

def notify_mr_hugg(state: EmailState):
    """Alfred notifica al Sr. Hugg sobre el correo y presenta el borrador de respuesta"""
    email = state["email"]
    
    print("\n" + "="*50)
    print(f"Se침or, ha recibido un correo electr칩nico de {email['sender']}.")
    print(f"Subject: {email['subject']}")
    print(f"Categor칤a: {state['email_category']}")
    print("\nHe preparado un borrador de respuesta para su revisi칩n:")
    print("-"*50)
    print(state["draft_response"])
    print("="*50 + "\n")
    
    # Hemos terminado de procesar este correo
    return {}
```

## Paso 3: Definir Nuestra L칩gica de Enrutamiento

Necesitamos una funci칩n para determinar qu칠 camino tomar despu칠s de la clasificaci칩n:

```python
def route_email(state: EmailState) -> str:
    """Determinar el siguiente paso basado en la clasificaci칩n de spam"""
    if state["is_spam"]:
        return "spam"
    else:
        return "legitimate"
```

> 游눠 **Nota:** Esta funci칩n de enrutamiento es llamada por LangGraph para determinar qu칠 arista(edge) seguir despu칠s del nodo de clasificaci칩n. El valor de retorno debe coincidir con una de las claves en nuestro mapeo de aristas(edges) condicionales.

## Paso 4: Crear el StateGraph y Definir Aristas(Edges)

Ahora conectamos todo:

```python
# Crear el grafo
email_graph = StateGraph(EmailState)

# A침adir nodos
email_graph.add_node("read_email", read_email)
email_graph.add_node("classify_email", classify_email)
email_graph.add_node("handle_spam", handle_spam)
email_graph.add_node("draft_response", draft_response)
email_graph.add_node("notify_mr_hugg", notify_mr_hugg)

# A침adir aristas(edges) - definiendo el flujo
email_graph.add_edge("read_email", "classify_email")

# A침adir ramificaci칩n condicional desde classify_email
email_graph.add_conditional_edges(
    "classify_email",
    route_email,
    {
        "spam": "handle_spam",
        "legitimate": "draft_response"
    }
)

# A침adir las aristas(edges) finales
email_graph.add_edge("handle_spam", END)
email_graph.add_edge("draft_response", "notify_mr_hugg")
email_graph.add_edge("notify_mr_hugg", END)

# Compilar el grafo
compiled_graph = email_graph.compile()
```

Observa c칩mo usamos el nodo especial  `END` proporcionado por LangGraph. Esto indica estados terminales donde el flujo de trabajo se completa.

## Paso 5: Ejecutar la Aplicaci칩n

Probemos nuestro grafo con un correo leg칤timo y un correo spam:

```python
# Ejemplo de correo leg칤timo
legitimate_email = {
    "sender": "john.smith@example.com",
    "subject": "Pregunta sobre sus servicios",
    "body": "Estimado Sr. Hugg, un colega me recomend칩 contactarle y estoy interesado en conocer m치s sobre sus servicios de consultor칤a. 쯇odr칤amos programar una llamada la pr칩xima semana? Saludos cordiales, John Smith"
}

# Ejemplo de correo spam
spam_email = {
    "sender": "winner@lottery-intl.com",
    "subject": 춰춰춰HAS GANADO $5,000,000!!!",
    "body": "춰FELICIDADES! 춰Has sido seleccionado como el ganador de nuestra loter칤a internacional! Para reclamar tu premio de $5,000,000, por favor env칤anos tus datos bancarios y una tarifa de procesamiento de $100."
}

# Procesar el correo leg칤timo
print("\nProcesando correo leg칤timo...")
legitimate_result = compiled_graph.invoke({
    "email": legitimate_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "draft_response": None,
    "messages": []
})

# Procesar el correo spam
print("\nProcesando correo spam...")
spam_result = compiled_graph.invoke({
    "email": spam_email,
    "is_spam": None,
    "spam_reason": None,
    "email_category": None,
    "draft_response": None,
    "messages": []
})
```

## Paso 6: Inspeccionando Nuestro Agente de Clasificaci칩n de Correo con Langfuse 游니

Mientras Alfred perfecciona el Agente de Clasificaci칩n de Correo, se est치 cansando de depurar sus ejecuciones. Los agentes, por naturaleza, son impredecibles y dif칤ciles de inspeccionar. Pero como su objetivo es construir el mejor Agente de Detecci칩n de Spam y desplegarlo en producci칩n, necesita una trazabilidad robusta para el monitoreo y an치lisis futuros.

Para hacer esto, Alfred puede usar una herramienta de observabilidad como [Langfuse](https://langfuse.com/) para rastrear y monitorear el agente.

Primero, instalamos Langfuse con pip: 
```python
%pip install -q langfuse
```

Luego, agregamos las claves API de Langfuse y la direcci칩n del host como variables de entorno. Puedes obtener tus credenciales de Langfuse registr치ndote en [Langfuse Cloud](https://cloud.langfuse.com) o [self-host Langfuse](https://langfuse.com/self-hosting). 

```python
import os
 
# Obt칠n las claves para tu proyecto desde la p치gina de configuraci칩n del proyecto: https://cloud.langfuse.com
os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..."
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # 游쀯릖 regi칩n de la UE
# os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # 游쥟릖 regi칩n de EE.U
```

Luego, configuramos el [Langfuse `callback_handler`](https://langfuse.com/docs/integrations/langchain/tracing#add-langfuse-to-your-langchain-application) instrumentamos el agente a침adiendo el `langfuse_callback` a la invocaci칩n del grafo: `config={"callbacks": [langfuse_handler]}`.

```python   
from langfuse.callback import CallbackHandler

# Inicializar CallbackHandler de Langfuse para LangGraph/Langchain (trazado)
langfuse_handler = CallbackHandler()

# Procesar correo leg칤timo
legitimate_result = compiled_graph.invoke(
    input={"email": legitimate_email, "is_spam": None, "spam_reason": None, "email_category": None, "draft_response": None, "messages": []},
    config={"callbacks": [langfuse_handler]}
)
```

춰Alfred est치 ahora conectado 游댋! Las ejecuciones de LangGraph se est치n registrando en Langfuse, d치ndole visibilidad completa del comportamiento del agente. Con esta configuraci칩n, est치 listo para revisar ejecuciones anteriores y refinar a칰n m치s su Agente de Clasificaci칩n de Correo.  

![Example trace in Langfuse](https://langfuse.com/images/cookbook/huggingface-agent-course/langgraph-trace-legit.png)

_[Public link to the trace with the legit email](https://cloud.langfuse.com/project/cloramnkj0002jz088vzn1ja4/traces/f5d6d72e-20af-4357-b232-af44c3728a7b?timestamp=2025-03-17T10%3A13%3A28.413Z&observation=6997ba69-043f-4f77-9445-700a033afba1)_

Visualizando Nuestro Grafo

LangGraph nos permite visualizar nuestro flujo de trabajo para entender y depurar mejor su estructura:

```python
compiled_graph.get_graph().draw_mermaid_png()
```
<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/LangGraph/mail_flow.png" alt="Mail LangGraph"/>

Esto produce una representaci칩n visual que muestra c칩mo est치n conectados nuestros nodos y los caminos condicionales que se pueden tomar.

## Lo Que Hemos Construido

Hemos creado un flujo de trabajo completo de procesamiento de correos electr칩nicos que:

1. Toma un correo electr칩nico entrante
2. Usa un LLM para clasificarlo como spam o leg칤timo
3. Maneja el spam descart치ndolo
4. Para correos leg칤timos, redacta una respuesta y notifica al Sr. Hugg

Esto demuestra el poder de LangGraph para orquestar flujos de trabajo complejos con LLMs mientras mantiene un flujo claro y estructurado.

## Puntos Clave

- **Gesti칩n de Estado**: Definimos un estado completo para rastrear todos los aspectos del procesamiento de correos electr칩nicos
- **Implementaci칩n de Nodos:**: Creamos nodos funcionales que interact칰an con un LLM
- **Enrutamiento Condicional**: Implementamos l칩gica de ramificaci칩n basada en la clasificaci칩n de correos
- **Estados Terminales:**: Usamos el nodo END para marcar puntos de finalizaci칩n en nuestro flujo de trabajo

## 쯈u칠 Sigue?

En la siguiente secci칩n, exploraremos caracter칤sticas m치s avanzadas de LangGraph, incluyendo el manejo de interacci칩n humana en el flujo de trabajo y la implementaci칩n de l칩gica de ramificaci칩n m치s compleja basada en m칰ltiples condiciones.
